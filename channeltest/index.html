<!DOCTYPE html>
<!--
*
* Copyright (C) 2017, bitmovin GmbH, All Rights Reserved
*
* This source code and its use and distribution, is subject to the terms
* and conditions of the applicable license agreement.
*
-->
<html lang="en">
<head>
    <title>Browser Audio Channels Test</title>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>

    <style>
        body {
            font-family: 'Open Sans', sans-serif;
            color: #fff;
            font-weight: 300;

            background: rgba(44, 131, 185, 1);
            background: -moz-linear-gradient(left, rgba(44, 131, 185, 1) 0%, rgba(30, 171, 227, 1) 100%);
            background: -webkit-gradient(left top, right top, color-stop(0%, rgba(44, 131, 185, 1)), color-stop(100%, rgba(30, 171, 227, 1)));
            background: -webkit-linear-gradient(left, rgba(44, 131, 185, 1) 0%, rgba(30, 171, 227, 1) 100%);
            background: -o-linear-gradient(left, rgba(44, 131, 185, 1) 0%, rgba(30, 171, 227, 1) 100%);
            background: -ms-linear-gradient(left, rgba(44, 131, 185, 1) 0%, rgba(30, 171, 227, 1) 100%);
            background: linear-gradient(to right, rgba(44, 131, 185, 1) 0%, rgba(30, 171, 227, 1) 100%);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#2c83b9', endColorstr='#1eabe3', GradientType=1);
        }
        figure {
            margin: 0;
            padding: 0;
        }
        .container {
            color: white;
            text-align: center;
        }
        .container a {
            color: #97d9ef;
            font-weight: 400;
            text-decoration: none;
        }
        .container a:hover {
            color: #fff;
        }
        .container h1 {
            margin-bottom: 22px;
            line-height: 66px;
        }
        .container h2 {
            font-weight: normal;
            margin-bottom: 36px;
            line-height: 26px;
        }
        .player-wrapper {
            width: 95%;
            margin: 20px auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
        }

        @media (min-width: 800px) {
            .container {
                width: 800px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        #results {
            width: 100%;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="content">
        <div class="player-wrapper">
            <table id="results">
                <thead>
                <tr>
                    <th>File</th>
                    <th>Channels</th>
                    <th>Channel Mapping</th>
                </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="description">
            <p>For more information about the bitmovin player, please have a look at our online <a href="https://bitmovin.com/support" target="_blank">Developer Section</a>.</p>
        </div>
    </div>
</div>
<script type="text/javascript">
  const extensions = ['.wav', '.aac', '.ogg', '-wav.mp4', '-aac.mp4', '-ogg.mp4'];
  const filenames = [];
  for (let ch = 1; ch <= 16; ch++) {
    let filename = ch + 'ch';
    extensions.forEach((ext) => {
      filenames.push(filename + ext);
    });
  }
  console.log(filenames);

  // Takes one sample from each channels, determines the peak frequency bin, and infers the channel number from it
  // ch 0 = 100 Hz, ch 1 = 200 Hz, etc...
  function analyse(analyserNodes, sR) {
    // contains the channel order; the count is the array length
    const channelCountAndOrder = [];

    analyserNodes.forEach((analyserNode, index) => {
      const dataArray = new Float32Array(analyserNode.frequencyBinCount);
      analyserNode.getFloatFrequencyData(dataArray);
      const maxIndex = dataArray.indexOf(Math.max(...dataArray));
      const maxFreq = sR / 2 / analyserNode.frequencyBinCount * maxIndex;
      const normalizedFreq = Math.round(maxFreq / 100) * 100;
      const estimatedChannelNum = normalizedFreq / 100 - 1;
      console.log(index + ' sr / maxIndex / freqAtMaxIndex / normalized freq / estimated channel num',
        sR, maxIndex, maxFreq, normalizedFreq, estimatedChannelNum);

      channelCountAndOrder.push(estimatedChannelNum);
    });

    return channelCountAndOrder;
  }

  function analyseFile(filename) {
    return new Promise((resolve, reject) => {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioContext;
      let sourceNode;
      let analyserNodes = [];

      const loadFile = (filename) => {
        return new Promise((resolve, reject) => {
          const request = new XMLHttpRequest();
          request.open('GET', filename, true);
          request.responseType = 'arraybuffer';
          request.addEventListener('load', () => {
            if (request.status === 404) {
              reject('not found');
            } else {
              audioContext.decodeAudioData(request.response,
                (buffer) => resolve(buffer),
                () => reject('cannot decode'));
            }
          });
          request.addEventListener('error', () => {
            reject('xhr failed');
          });
          request.send();
        });
      };

      const init = () => {
        audioContext = new AudioContext();
        sourceNode = audioContext.createBufferSource();

        const channelCountFromFilename = Number(filename.split('ch')[0]);

        console.log('channels', sourceNode.channelCount, 'fromFilename', channelCountFromFilename);

        let splitterNode = audioContext.createChannelSplitter(channelCountFromFilename);
        sourceNode.connect(splitterNode);

        for (let ch = 0; ch < channelCountFromFilename; ch++) {
          let analyserNode = audioContext.createAnalyser();
          splitterNode.connect(analyserNode, ch);
          analyserNode.fftSize = 2048;
          analyserNodes.push(analyserNode);
        }
      };

      const teardown = () => {
        if (audioContext) {
          return audioContext.close();
        } else {
          return Promise.resolve();
        }
      };

      init();

      loadFile(filename).then(buffer => {
        sourceNode.buffer = buffer;
        sourceNode.start(0);
      }).then(() => {
        setTimeout(() => {
          try {
            const channelCountAndOrder = analyse(analyserNodes, audioContext.sampleRate);
            teardown().then(() => {
              resolve(channelCountAndOrder);
            });
          } catch (error) {
            reject(error);
          }
        }, 100);
      }).catch((error) => {
        return teardown().then(() => {
          reject(error);
        });
      });
    });
  }

  // Test files one by one
  let analysisChain = Promise.resolve();
  filenames.forEach(filename => {
    analysisChain = analysisChain.then(() => {
      return analyseFile(filename).then(channelCountAndOrder => {
        console.log('result: ' + channelCountAndOrder.length + ' channels, mapping: ' + channelCountAndOrder);
        $('#results > tbody').append($(`
          <tr>
            <th>${filename}</th>
            <td>${channelCountAndOrder.length}</td>
            <td>${channelCountAndOrder}</td>
          </tr>
        `));
      });
    }).catch(error => {
      console.error('error testing file ', filename, error);
      $('#results > tbody').append($(`
          <tr>
            <th>${filename}</th>
            <td colspan="2"><i>${error}</i></td>
          </tr>
        `));
    });
  })
</script>
</body>
</html>